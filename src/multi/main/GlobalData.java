package multi.main;

import java.util.ArrayList;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.LinkedBlockingQueue;

import multi.data.FlowKey;
import multi.data.Packet;

public class GlobalData {
	
	Random random;

	//global data generated by H2, and shared by all switches
	public ArrayList<ConcurrentHashMap<FlowKey, Long>> gNormalFlowMapBuffer = new ArrayList<ConcurrentHashMap<FlowKey, Long>>();
	public ArrayList<ConcurrentHashMap<FlowKey, Long>> gLostFlowMapBuffer = new ArrayList<ConcurrentHashMap<FlowKey, Long>>();
	public int gFlowMapBufferIdx;
	
	//used by Host2MainThread and Host2GenerateTargetSet
	public ConcurrentHashMap<FlowKey, Integer> gTargetFlowMap = new ConcurrentHashMap<FlowKey, Integer>();
	public ConcurrentHashMap<FlowKey, Integer> gTargetFlowMapEndOfInterval = new ConcurrentHashMap<FlowKey, Integer>();
	
	public LinkedBlockingQueue<Packet> S1InputQueue= new LinkedBlockingQueue<Packet>(10000); // 10M
	public LinkedBlockingQueue<Packet> S2InputQueue = new LinkedBlockingQueue<Packet>(10000); // 10M
	public LinkedBlockingQueue<Packet> S3InputQueue = new LinkedBlockingQueue<Packet>(10000); // 10M
	public LinkedBlockingQueue<Packet> S4InputQueue = new LinkedBlockingQueue<Packet>(10000); // 10M
	public ConcurrentMap<Packet, Integer> H2InputSet = new ConcurrentHashMap<Packet, Integer>(); // 10M
	public LinkedBlockingQueue<Packet> H2TruthQueue = new LinkedBlockingQueue<Packet>(10000); // 10M
	public long currentMaxPktTimestamp;
	
	//signal for all threads.
	public boolean AllIntervalsCompleted;
	public boolean h1exit;
	public boolean s1exit;
	public boolean s2exit;
	public boolean s3exit;
	public boolean s4exit;
	
	private GlobalData() {
		random = new Random(System.currentTimeMillis());
		//2 buffers
		gNormalFlowMapBuffer.add(new ConcurrentHashMap<FlowKey, Long>());
		gNormalFlowMapBuffer.add(new ConcurrentHashMap<FlowKey, Long>());
		//2 buffers
		gLostFlowMapBuffer.add(new ConcurrentHashMap<FlowKey, Long>());
		gLostFlowMapBuffer.add(new ConcurrentHashMap<FlowKey, Long>());
		//
		gFlowMapBufferIdx = 0;
		
		AllIntervalsCompleted = false;
		h1exit = false;
		s1exit = false;
		s2exit = false;
		s3exit = false;
		s4exit = false;
	}
	
	public static GlobalData Instance() {
		return singleInstance;
	}
	
	private static GlobalData singleInstance = new GlobalData();
	
	//At the start of each interval, this function should be called
	public void clear() {		
		S1InputQueue.clear();
		S2InputQueue.clear();
		S3InputQueue.clear();
		S4InputQueue.clear();
		H2InputSet.clear();
		H2TruthQueue.clear();
		currentMaxPktTimestamp = 0;
	}
	
	public void insertIntoNormalFlowVolumeMap(FlowKey flow, Packet pkg) {
		ConcurrentHashMap<FlowKey, Long> gNormalFlowVolumeMap = gNormalFlowMapBuffer.get(gFlowMapBufferIdx);
		/* in order to get real loss rate */
		Long normalVolume = gNormalFlowVolumeMap.get(flow);
		if (normalVolume == null) {
			gNormalFlowVolumeMap.put(flow, pkg.length);
		} else {
			gNormalFlowVolumeMap.put(flow, normalVolume + pkg.length);
		}
		if (GlobalSetting.DEBUG && GlobalSetting.DEBUG_SRCIP == flow.srcip) {
			System.out.println("normal pkt-srcip:"+flow.srcip + ", normalVolume:" + gNormalFlowVolumeMap.get(flow));
		}
		/* in order to get real loss rate */
	}
	
	public void insertIntoLostFlowVolumeMap(FlowKey flow, Packet pkg) {
		ConcurrentHashMap<FlowKey, Long> gLostFlowVolumeMap = gLostFlowMapBuffer.get(gFlowMapBufferIdx);
		/* in order to get real loss rate */
		Long lostVolume = gLostFlowVolumeMap.get(flow);
		if (lostVolume == null) {
			gLostFlowVolumeMap.put(flow, pkg.length);
		} else {
			gLostFlowVolumeMap.put(flow, lostVolume + pkg.length);
		}
		if (GlobalSetting.DEBUG && GlobalSetting.DEBUG_SRCIP == flow.srcip) {
			System.out.println("lost pkt-srcip:"+flow.srcip + ", lostVolume:" + gLostFlowVolumeMap.get(flow));
		}
		/* in order to get real loss rate */
	}
	
	public double getLossRateForOneFlow(FlowKey flowKey) {
		ConcurrentHashMap<FlowKey, Long> gNormalFlowVolumeMap = gNormalFlowMapBuffer.get(gFlowMapBufferIdx);
		ConcurrentHashMap<FlowKey, Long> gLostFlowVolumeMap = gLostFlowMapBuffer.get(gFlowMapBufferIdx);
		double lossRate = 0;
		Long flowLostVolume = gLostFlowVolumeMap.get(flowKey);
		if (null == flowLostVolume) {
			flowLostVolume = 0L;
		}
		Long normalVolume = gNormalFlowVolumeMap.get(flowKey);
		if (null == normalVolume) {
			normalVolume = 0L;
		}
		Long totalVolume = flowLostVolume + normalVolume;
		lossRate = 1.0 * flowLostVolume / totalVolume;

		return lossRate;		
	}
	
	public long getTotalVolumeForOneFlow(FlowKey flowKey) {
		ConcurrentHashMap<FlowKey, Long> gNormalFlowVolumeMap = gNormalFlowMapBuffer.get(gFlowMapBufferIdx);
		ConcurrentHashMap<FlowKey, Long> gLostFlowVolumeMap = gLostFlowMapBuffer.get(gFlowMapBufferIdx);
		
		Long flowLostVolume = gLostFlowVolumeMap.get(flowKey);
		if (null == flowLostVolume) {
			flowLostVolume = 0L;
		}
		Long normalVolume = gNormalFlowVolumeMap.get(flowKey);
		if (null == normalVolume) {
			normalVolume = 0L;
		}
		Long totalVolume = flowLostVolume + normalVolume;
		
		return totalVolume;
	}
	
	public void switchFlowMapBuffers() {
		//switch global data buffer
		gFlowMapBufferIdx = 1 - gFlowMapBufferIdx;
		
		//new interval comes, 
		//keep the existing target flows buffer for calculation in the controller.
		gTargetFlowMapEndOfInterval.clear();
		for (Map.Entry<FlowKey, Integer> entry : gTargetFlowMap.entrySet()) {
			FlowKey flowKey = entry.getKey();
			gTargetFlowMapEndOfInterval.put(flowKey, 1);
		}
	}
}
